from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import json
from processing.pdf_structure_extractor import PDFStructureExtractor
from processing.document_analyst import DocumentAnalyst
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import gtts
from io import BytesIO

app = Flask(__name__)
CORS(app)

# --- Configuration ---
UPLOAD_FOLDER = 'uploads'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# --- In-memory Data Store (for simplicity) ---
# In a real app, use a database like SQLite or a proper DB
document_data = {}

# --- Initialize Processing Modules ---
structure_extractor = PDFStructureExtractor()
document_analyst = DocumentAnalyst()
tfidf_vectorizer = TfidfVectorizer()

def index_document(doc_id, sections):
    """Create a TF-IDF index for a document's sections."""
    if not sections:
        return
    document_data[doc_id]['indexed_sections'] = sections
    texts = [section['content'] for section in sections]
    document_data[doc_id]['tfidf_matrix'] = tfidf_vectorizer.fit_transform(texts)

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file and file.filename.endswith('.pdf'):
        filename = file.filename
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)

        # --- Process the uploaded PDF ---
        doc_id = filename
        document_data[doc_id] = {'filepath': filepath}

        # 1. Extract Structure
        structure = structure_extractor.extract(filepath)
        document_data[doc_id]['structure'] = structure

        # 2. Extract Sections
        sections = document_analyst.extract_sections_from_pdf(filepath)
        document_data[doc_id]['sections'] = sections
        
        # 3. Index Sections for Recommendations
        index_document(doc_id, sections)

        return jsonify({
            "message": "File uploaded and processed successfully",
            "filename": filename,
            "structure": structure,
            "sections": sections
        }), 200
    return jsonify({"error": "Invalid file type"}), 400

@app.route('/pdf/<filename>')
def get_pdf(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

@app.route('/recommendations', methods=['POST'])
def get_recommendations():
    data = request.json
    doc_id = data.get('doc_id')
    current_section_index = data.get('current_section_index')

    if not doc_id or doc_id not in document_data or 'tfidf_matrix' not in document_data[doc_id]:
        return jsonify({"error": "Document not found or not indexed"}), 404

    tfidf_matrix = document_data[doc_id]['tfidf_matrix']
    current_vector = tfidf_matrix[current_section_index]
    
    similarities = cosine_similarity(current_vector, tfidf_matrix).flatten()
    
    # Get top 5 related sections (excluding the section itself)
    related_indices = similarities.argsort()[-6:-1][::-1]
    
    recommendations = []
    all_sections = document_data[doc_id]['indexed_sections']
    for i in related_indices:
        if i != current_section_index:
            recommendations.append({
                "section_title": all_sections[i]['title'],
                "page_number": all_sections[i]['page_number'],
                "score": similarities[i]
            })

    return jsonify(recommendations)

@app.route('/insights', methods=['POST'])
def get_insights():
    data = request.json
    text = data.get('text')
    if not text:
        return jsonify({"error": "No text provided"}), 400

    # This is a mock response. In a real application, you would call the Gemini API here.
    # from google.generativeai import GenerativeModel
    # model = GenerativeModel('gemini-2.5-flash-preview-05-20')
    # response = model.generate_content(f"Provide key insights from this text: {text}")
    # insights = response.text
    
    mock_insights = {
        "key_points": [
            "This is a key insight generated by the AI.",
            "The document discusses important concepts related to the topic.",
            "Further analysis reveals a connection to another related field."
        ],
        "did_you_know": "This is an interesting fact related to the text."
    }
    
    return jsonify(mock_insights)

@app.route('/podcast', methods=['POST'])
def generate_podcast():
    data = request.json
    text = data.get('text')
    if not text:
        return jsonify({"error": "No text provided"}), 400
        
    try:
        tts = gtts.gTTS(text, lang="en")
        mp3_fp = BytesIO()
        tts.write_to_fp(mp3_fp)
        mp3_fp.seek(0)
        return send_file(mp3_fp, mimetype="audio/mpeg", as_attachment=False)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    app.run(debug=True, port=5001)